---
import type { MediaFile } from '@/types/service';
import 'glightbox/dist/css/glightbox.css';

interface Props {
  mediaFiles: MediaFile[];
  preview?: boolean;
}

const { mediaFiles, preview = false } = Astro.props;
const mediaToShow = preview ? mediaFiles.slice(0, 6) : mediaFiles;
---

<div class="relative w-full">
  <div class="gallery-masonry">
    {
      mediaToShow.map((mediaFile, index) => (
        <a
          href={`${mediaFile.url}_highres.webp`}
          class="gallery-item group relative block cursor-pointer overflow-hidden rounded-lg bg-gray-100 transition-all duration-300 hover:-translate-y-1 hover:shadow-xl"
          data-gallery="gallery"
          style={`animation-delay: ${index * 0.05}s`}
        >
          <img
            src={`${mediaFile.url}_thumb.webp`}
            alt={mediaFile.alt}
            loading="lazy"
            class="h-auto w-full object-cover transition-transform duration-500 group-hover:scale-105"
          />
          <div class="absolute inset-0 flex items-center justify-center bg-black/40 opacity-0 transition-opacity duration-300 group-hover:opacity-100">
            <svg
              class="h-8 w-8 text-white drop-shadow-lg"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
              stroke-width="2"
            >
              <circle cx="11" cy="11" r="8" />
              <path d="m21 21-4.35-4.35" />
              <line x1="11" y1="8" x2="11" y2="14" />
              <line x1="8" y1="11" x2="14" y2="11" />
            </svg>
          </div>
        </a>
      ))
    }
  </div>

  {
    preview && (
      <div class="pointer-events-none absolute right-0 bottom-0 left-0 h-40 bg-gradient-to-b from-transparent to-white" />
    )
  }
</div>

<style>
  .gallery-masonry {
    columns: 1;
    column-gap: 0.75rem;
  }

  @media (min-width: 640px) {
    .gallery-masonry {
      columns: 2;
      column-gap: 1rem;
    }
  }

  @media (min-width: 1024px) {
    .gallery-masonry {
      columns: 3;
      column-gap: 1.25rem;
    }
  }

  @media (min-width: 1280px) {
    .gallery-masonry {
      columns: 4;
      column-gap: 1.5rem;
    }
  }

  .gallery-item {
    display: inline-block;
    width: 100%;
    margin-bottom: 0.75rem;
    animation: fadeInUp 0.6s ease backwards;
  }

  @media (min-width: 640px) {
    .gallery-item {
      margin-bottom: 1rem;
    }
  }

  @media (min-width: 1024px) {
    .gallery-item {
      margin-bottom: 1.25rem;
    }
  }

  @media (min-width: 1280px) {
    .gallery-item {
      margin-bottom: 1.5rem;
    }
  }

  @keyframes fadeInUp {
    from {
      opacity: 0;
      transform: translateY(20px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }
</style>

<script>
  import GLightbox from 'glightbox';

  // Inicializar lightbox
  const lightbox = GLightbox({
    selector: '.glightbox',
    touchNavigation: true,
    loop: true,
    autoplayVideos: true,
    closeButton: true,
    zoomable: true,
    draggable: true,
  });

  // Intersection Observer para lazy loading mejorado
  const images = document.querySelectorAll('.gallery-item img');

  const imageObserver = new IntersectionObserver(
    (entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          const img = entry.target as HTMLImageElement;

          // Precargar la imagen de alta resolución cuando está cerca del viewport
          // const link = img.closest('a');
          // if (link) {
          //   const highResUrl = link.getAttribute('href');
          //   if (highResUrl) {
          //     const preloadImg = new Image();
          //     preloadImg.src = highResUrl;
          //   }
          // }

          imageObserver.unobserve(img);
        }
      });
    },
    {
      rootMargin: '100px', // Precargar 100px antes de que sea visible
    },
  );

  images.forEach((img) => imageObserver.observe(img));
</script>
